# JAVA의 동작 원리



- JAVA는 어느 플랫폼, 하드웨어, 운영체제에 관계없이 컴파일된 코드(바이트 코드) 가 독립적이다.
- 이러한 특징을 구현하기 위해서는 JVM(JAVA Virtual Machine)이 필요하다.
- JVM은 H/W와 OS 위에서 실행되기 때문에 JVM 자체는 플랫폼에 종속적인 호환되는 JVM을 실행시켜줄 필요성이 있다.







### JVM Internal

> JRE는 자바 API와 JVM으로 구성되어 있으며, JVM의 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행시키는 것이다.



#### JVM의 특징

- 스택 기반의 가상머신

  > 대표적인 컴퓨터 아키텍쳐인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는데 비해 JVM은 스택 기반으로 동작한다.

- 심볼릭 래퍼런스

  > 기본 자료형을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 러퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.

- 가비지 컬렉션

  > 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.

- 기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장

  > C/C++등 언어는 플랫폼에 따라 int 형의 크기가 변한다. JVM은 기본 자료형을 명확하게 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.

- 네트워크 바이트 오더:

  > 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 플랫폼의 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다.
  >
  > * 네트워크 바이트 오더는 빅 엔디안 이다.





WORA(Write Once Run Anywhere)을 구현하기 위해 JVM은 사용자 언어인 자바와 기계어 사이의 중간 언어인 자바 바이트 코드를 사용한다. 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위이다.



TODO : JAVA 바이트 코드 정리 할 것.



### JVM 구조

#### JAVA 코드의 실행 과정

- 작성한 자바소스, 확장자가 .java인 파일을 자바 컴파일러를 통하여 자바 바이트 코드로 컴파일 한다.
- 컴파일된 바이트 코드를 JVM의 클래스로더에게 전달한다.
- 클래스로더는동적로딩을 통하여 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM 메모리에 올린다.
- 실행엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다.

`아래 상세 정리`

![JVMInternal1](https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png)

> 자바로 작성한 코드는 다음 그림과 같은 과정을 통해 수행된다.
>
> 클래스 로더가 컴파일된 자바 바이트코드를 런타임 데이터 영역에 로드하고 실행 엔진이 자바 바이트 코드를 실행한다.



TODO: 항목별 상세 정리



> 참고
>
> https://steady-snail.tistory.com/67
>
> https://d2.naver.com/helloworld/1230

